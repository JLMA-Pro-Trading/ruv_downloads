{"version":3,"sources":["../src/pure/types.ts","../src/pure/scores.ts","../src/pure/conformal.ts","../src/factory.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * Core types for conformal prediction\n */\n\nexport interface PredictionInterval {\n  /** Point prediction from base model */\n  point: number;\n\n  /** Lower bound of prediction interval */\n  lower: number;\n\n  /** Upper bound of prediction interval */\n  upper: number;\n\n  /** Miscoverage rate (1 - coverage) */\n  alpha: number;\n\n  /** Computed quantile threshold */\n  quantile: number;\n\n  /** Timestamp of prediction */\n  timestamp: number;\n\n  /** Width of the interval */\n  width(): number;\n\n  /** Check if value is in interval */\n  contains(value: number): boolean;\n\n  /** Relative width as percentage */\n  relativeWidth(): number;\n\n  /** Expected coverage (1 - alpha) */\n  coverage(): number;\n}\n\nexport class PredictionIntervalImpl implements PredictionInterval {\n  constructor(\n    public point: number,\n    public lower: number,\n    public upper: number,\n    public alpha: number,\n    public quantile: number,\n    public timestamp: number = Date.now()\n  ) {}\n\n  width(): number {\n    return this.upper - this.lower;\n  }\n\n  contains(value: number): boolean {\n    return value >= this.lower && value <= this.upper;\n  }\n\n  relativeWidth(): number {\n    if (Math.abs(this.point) < Number.EPSILON) {\n      return Infinity;\n    }\n    return (this.width() / Math.abs(this.point)) * 100;\n  }\n\n  coverage(): number {\n    return 1 - this.alpha;\n  }\n}\n\nexport interface PredictorConfig {\n  /** Miscoverage rate (e.g., 0.1 for 90% coverage) */\n  alpha: number;\n\n  /** Maximum calibration set size */\n  calibrationSize?: number;\n\n  /** Maximum interval width as percentage */\n  maxIntervalWidthPct?: number;\n\n  /** Recalibration frequency (number of predictions) */\n  recalibrationFreq?: number;\n}\n\nexport interface AdaptiveConfig {\n  /** Target coverage (e.g., 0.90 for 90%) */\n  targetCoverage: number;\n\n  /** Learning rate for PID control */\n  gamma: number;\n\n  /** Window size for coverage tracking */\n  coverageWindow?: number;\n\n  /** Minimum alpha value */\n  alphaMin?: number;\n\n  /** Maximum alpha value */\n  alphaMax?: number;\n}\n\nexport const defaultPredictorConfig: Required<PredictorConfig> = {\n  alpha: 0.1,\n  calibrationSize: 2000,\n  maxIntervalWidthPct: 5.0,\n  recalibrationFreq: 100,\n};\n\nexport const defaultAdaptiveConfig: Required<AdaptiveConfig> = {\n  targetCoverage: 0.90,\n  gamma: 0.02,\n  coverageWindow: 200,\n  alphaMin: 0.01,\n  alphaMax: 0.30,\n};\n","/**\n * Nonconformity score functions\n */\n\nexport interface NonconformityScore {\n  /** Compute nonconformity score */\n  score(prediction: number, actual: number): number;\n\n  /** Compute prediction interval given quantile */\n  interval(prediction: number, quantile: number): [number, number];\n}\n\n/**\n * Absolute residual score: |actual - prediction|\n */\nexport class AbsoluteScore implements NonconformityScore {\n  score(prediction: number, actual: number): number {\n    return Math.abs(actual - prediction);\n  }\n\n  interval(prediction: number, quantile: number): [number, number] {\n    return [prediction - quantile, prediction + quantile];\n  }\n}\n\n/**\n * Normalized score: residual divided by model uncertainty\n */\nexport class NormalizedScore implements NonconformityScore {\n  constructor(private stdDev: number = 1.0) {}\n\n  score(prediction: number, actual: number): number {\n    return Math.abs(actual - prediction) / Math.max(this.stdDev, 1e-6);\n  }\n\n  interval(prediction: number, quantile: number): [number, number] {\n    const width = quantile * this.stdDev;\n    return [prediction - width, prediction + width];\n  }\n\n  /** Update standard deviation estimate */\n  updateStdDev(stdDev: number): void {\n    this.stdDev = Math.max(stdDev, 1e-6);\n  }\n}\n\n/**\n * Quantile-based score for CQR\n */\nexport class QuantileScore implements NonconformityScore {\n  constructor(alphaLow: number = 0.05, alphaHigh: number = 0.95) {\n    if (alphaLow < 0 || alphaLow >= alphaHigh || alphaHigh > 1) {\n      throw new Error('Invalid quantile values');\n    }\n    // Validation complete - parameters validated but not stored as they're only used for validation\n  }\n\n  score(prediction: number, actual: number): number {\n    // For CQR, prediction should be [lower, upper] quantiles\n    // But for compatibility, we use symmetric assumption\n    const half = prediction * 0.05; // Approximate quantile range\n    return Math.max(prediction - half - actual, actual - (prediction + half));\n  }\n\n  interval(prediction: number, quantile: number): [number, number] {\n    return [prediction - quantile, prediction + quantile];\n  }\n\n  /**\n   * Compute score for quantile predictions\n   */\n  scoreQuantiles(qLow: number, qHigh: number, actual: number): number {\n    return Math.max(qLow - actual, actual - qHigh);\n  }\n}\n","/**\n * Pure TypeScript implementation of conformal prediction algorithms\n * Ports Rust algorithms with efficient sorting and binary search\n */\n\nimport {\n  PredictionInterval,\n  PredictionIntervalImpl,\n  PredictorConfig,\n  AdaptiveConfig,\n  defaultPredictorConfig,\n  defaultAdaptiveConfig,\n} from './types';\nimport { NonconformityScore, AbsoluteScore } from './scores';\n\n/**\n * Split Conformal Predictor\n * Provides distribution-free prediction intervals with guaranteed coverage\n *\n * Mathematical guarantee: P(y ∈ [lower, upper]) ≥ 1 - α\n */\nexport class SplitConformalPredictor {\n  private alpha: number;\n  private calibrationSize: number;\n  private recalibrationFreq: number;\n  private scoreFunction: NonconformityScore;\n\n  private calibrationScores: number[] = [];\n  private quantile: number = 0;\n  private nCalibration: number = 0;\n  private predictionCount: number = 0;\n\n  constructor(config: Partial<PredictorConfig> = {}, scoreFunction?: NonconformityScore) {\n    const fullConfig = { ...defaultPredictorConfig, ...config };\n    this.alpha = fullConfig.alpha;\n    this.calibrationSize = fullConfig.calibrationSize;\n    // maxIntervalWidthPct from config reserved for future interval width constraints\n    void fullConfig.maxIntervalWidthPct;\n    this.recalibrationFreq = fullConfig.recalibrationFreq;\n    this.scoreFunction = scoreFunction || new AbsoluteScore();\n  }\n\n  /**\n   * Calibrate the predictor with historical data\n   * O(n log n) due to sorting\n   *\n   * @param predictions - Model's point predictions\n   * @param actuals - Actual observed values\n   */\n  async calibrate(predictions: number[], actuals: number[]): Promise<void> {\n    if (predictions.length !== actuals.length) {\n      throw new Error('Predictions and actuals must have same length');\n    }\n\n    if (predictions.length === 0) {\n      throw new Error('At least one calibration sample required');\n    }\n\n    // Compute nonconformity scores\n    const scores: number[] = [];\n    for (let i = 0; i < predictions.length; i++) {\n      const score = this.scoreFunction.score(predictions[i], actuals[i]);\n      scores.push(score);\n    }\n\n    // Sort scores for quantile computation\n    scores.sort((a, b) => a - b);\n\n    this.calibrationScores = scores;\n    this.nCalibration = scores.length;\n    this.updateQuantile();\n  }\n\n  /**\n   * Make a prediction with a confidence interval\n   * O(1) time after calibration\n   *\n   * @param pointPrediction - Model's point prediction\n   * @returns PredictionInterval with bounds\n   */\n  predict(pointPrediction: number): PredictionInterval {\n    if (this.nCalibration === 0) {\n      throw new Error('Predictor not calibrated');\n    }\n\n    const [lower, upper] = this.scoreFunction.interval(pointPrediction, this.quantile);\n\n    const interval = new PredictionIntervalImpl(\n      pointPrediction,\n      lower,\n      upper,\n      this.alpha,\n      this.quantile\n    );\n\n    this.predictionCount++;\n    return interval;\n  }\n\n  /**\n   * Update predictor with new observation\n   * O(log n) via binary search insertion\n   *\n   * @param prediction - Model's point prediction\n   * @param actual - Actual observed value\n   */\n  async update(prediction: number, actual: number): Promise<void> {\n    const score = this.scoreFunction.score(prediction, actual);\n\n    // Binary search for insertion point\n    const insertPos = this.binarySearchInsertPosition(score);\n    this.calibrationScores.splice(insertPos, 0, score);\n\n    // Maintain maximum window size\n    if (this.calibrationScores.length > this.calibrationSize) {\n      this.calibrationScores.shift();\n    }\n\n    this.nCalibration = this.calibrationScores.length;\n    this.updateQuantile();\n  }\n\n  /**\n   * Trigger full recalibration if needed\n   */\n  async recalibrate(predictions: number[], actuals: number[]): Promise<void> {\n    if (this.predictionCount % this.recalibrationFreq === 0) {\n      await this.calibrate(predictions, actuals);\n      this.predictionCount = 0;\n    }\n  }\n\n  /**\n   * Get empirical coverage from calibration set\n   */\n  getEmpiricalCoverage(predictions: number[], actuals: number[]): number {\n    if (predictions.length === 0) return 0;\n\n    let covered = 0;\n    for (let i = 0; i < predictions.length; i++) {\n      const interval = this.predict(predictions[i]);\n      if (interval.contains(actuals[i])) {\n        covered++;\n      }\n    }\n\n    return covered / predictions.length;\n  }\n\n  /**\n   * Get calibration statistics\n   */\n  getStats() {\n    return {\n      nCalibration: this.nCalibration,\n      alpha: this.alpha,\n      quantile: this.quantile,\n      predictionCount: this.predictionCount,\n      minScore: this.calibrationScores[0] ?? 0,\n      maxScore: this.calibrationScores[this.nCalibration - 1] ?? 0,\n    };\n  }\n\n  /**\n   * Update the quantile threshold based on sorted scores\n   * Follows: q = ceil((n+1)(1-alpha))/n\n   * @private\n   */\n  private updateQuantile(): void {\n    if (this.nCalibration === 0) {\n      this.quantile = 0;\n      return;\n    }\n\n    // Compute quantile index: ceil((n+1)(1-alpha))/n\n    const index = Math.ceil((this.nCalibration + 1) * (1 - this.alpha)) - 1;\n    const clampedIndex = Math.max(0, Math.min(index, this.nCalibration - 1));\n    this.quantile = this.calibrationScores[clampedIndex];\n  }\n\n  /**\n   * Find binary search insertion position\n   * @private\n   */\n  private binarySearchInsertPosition(score: number): number {\n    let left = 0;\n    let right = this.calibrationScores.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.calibrationScores[mid] < score) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n\n    return left;\n  }\n}\n\n/**\n * Adaptive Conformal Inference (ACI)\n * Dynamically adjusts alpha using PID control to track target coverage\n *\n * Maintains empirical coverage close to target by adapting alpha during streaming\n */\nexport class AdaptiveConformalPredictor {\n  private targetCoverage: number;\n  private gamma: number;\n  private coverageWindow: number;\n  private alphaMin: number;\n  private alphaMax: number;\n\n  private basePredictorConfig: Partial<PredictorConfig>;\n  private basePredictor: SplitConformalPredictor;\n  private scoreFunction: NonconformityScore;\n\n  private coverageHistory: number[] = [];\n  private alphaCurrent: number;\n\n  constructor(\n    config: Partial<AdaptiveConfig> = {},\n    scoreFunction?: NonconformityScore\n  ) {\n    const fullConfig = { ...defaultAdaptiveConfig, ...config };\n    this.targetCoverage = fullConfig.targetCoverage;\n    this.gamma = fullConfig.gamma;\n    this.coverageWindow = fullConfig.coverageWindow;\n    this.alphaMin = fullConfig.alphaMin;\n    this.alphaMax = fullConfig.alphaMax;\n\n    this.scoreFunction = scoreFunction || new AbsoluteScore();\n    this.alphaCurrent = 1 - this.targetCoverage;\n\n    this.basePredictorConfig = {\n      alpha: this.alphaCurrent,\n    };\n\n    this.basePredictor = new SplitConformalPredictor(\n      this.basePredictorConfig,\n      this.scoreFunction\n    );\n  }\n\n  /**\n   * Initialize with calibration data\n   *\n   * @param predictions - Initial predictions for calibration\n   * @param actuals - Actual values for calibration\n   */\n  async calibrate(predictions: number[], actuals: number[]): Promise<void> {\n    await this.basePredictor.calibrate(predictions, actuals);\n  }\n\n  /**\n   * Make prediction and adapt alpha based on coverage\n   * O(log n) with binary search\n   *\n   * @param pointPrediction - Model's point prediction\n   * @param actual - Optional actual value for adaptation\n   * @returns PredictionInterval\n   */\n  async predictAndAdapt(pointPrediction: number, actual?: number): Promise<PredictionInterval> {\n    // Make prediction with current alpha\n    const interval = this.basePredictor.predict(pointPrediction);\n\n    // If actual is provided, adapt alpha\n    if (actual !== undefined) {\n      const covered = interval.contains(actual) ? 1 : 0;\n      this.coverageHistory.push(covered);\n\n      // Maintain window size\n      if (this.coverageHistory.length > this.coverageWindow) {\n        this.coverageHistory.shift();\n      }\n\n      // PID control: adjust alpha based on coverage error\n      const empirical = this.empiricalCoverage();\n      const error = this.targetCoverage - empirical;\n\n      // Update alpha: alpha -= gamma * error\n      this.alphaCurrent -= this.gamma * error;\n\n      // Clamp alpha to valid range\n      this.alphaCurrent = Math.max(this.alphaMin, Math.min(this.alphaMax, this.alphaCurrent));\n\n      // Update base predictor's alpha\n      const updatedConfig = { ...this.basePredictorConfig, alpha: this.alphaCurrent };\n      this.basePredictor = new SplitConformalPredictor(updatedConfig, this.scoreFunction);\n\n      // Update base predictor with new observation\n      await this.basePredictor.update(pointPrediction, actual);\n    }\n\n    return interval;\n  }\n\n  /**\n   * Standard prediction without adaptation\n   *\n   * @param pointPrediction - Model's point prediction\n   * @returns PredictionInterval\n   */\n  predict(pointPrediction: number): PredictionInterval {\n    return this.basePredictor.predict(pointPrediction);\n  }\n\n  /**\n   * Update predictor with new observation\n   *\n   * @param prediction - Model's point prediction\n   * @param actual - Actual observed value\n   */\n  async update(prediction: number, actual: number): Promise<void> {\n    await this.basePredictor.update(prediction, actual);\n  }\n\n  /**\n   * Compute empirical coverage from history\n   * Simple average of coverage indicator in the window\n   */\n  empiricalCoverage(): number {\n    if (this.coverageHistory.length === 0) {\n      return this.targetCoverage; // Default to target if no history\n    }\n\n    const sum = this.coverageHistory.reduce((a, b) => a + b, 0);\n    return sum / this.coverageHistory.length;\n  }\n\n  /**\n   * Get current alpha value\n   */\n  getCurrentAlpha(): number {\n    return this.alphaCurrent;\n  }\n\n  /**\n   * Get statistics including coverage metrics\n   */\n  getStats() {\n    const empirical = this.empiricalCoverage();\n    return {\n      ...this.basePredictor.getStats(),\n      alphaCurrent: this.alphaCurrent,\n      empiricalCoverage: empirical,\n      targetCoverage: this.targetCoverage,\n      coverageDifference: this.targetCoverage - empirical,\n      coverageHistorySize: this.coverageHistory.length,\n    };\n  }\n}\n\n/**\n * Conformalized Quantile Regression (CQR) Predictor\n * Uses quantile predictions from model for prediction intervals\n */\nexport class CQRPredictor {\n  private alpha: number;\n  private calibrationSize: number;\n  // @ts-ignore scoreFunction reserved for future quantile-based extensions\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private scoreFunction: NonconformityScore;\n\n  private calibrationScores: number[] = [];\n  private quantile: number = 0;\n  private nCalibration: number = 0;\n\n  private alphaLow: number;\n  private alphaHigh: number;\n\n  constructor(\n    config: Partial<PredictorConfig> = {},\n    alphaLow: number = 0.05,\n    alphaHigh: number = 0.95,\n    scoreFunction?: NonconformityScore\n  ) {\n    if (alphaLow < 0 || alphaLow >= alphaHigh || alphaHigh > 1) {\n      throw new Error('Invalid quantile values');\n    }\n\n    const fullConfig = { ...defaultPredictorConfig, ...config };\n    this.alpha = fullConfig.alpha;\n    this.calibrationSize = fullConfig.calibrationSize;\n    // scoreFunction reserved for future quantile-based extensions\n    this.scoreFunction = scoreFunction || new AbsoluteScore();\n    this.alphaLow = alphaLow;\n    this.alphaHigh = alphaHigh;\n  }\n\n  /**\n   * Calibrate with quantile predictions\n   *\n   * @param qLow - Lower quantile predictions\n   * @param qHigh - Upper quantile predictions\n   * @param actuals - Actual observed values\n   */\n  async calibrate(qLow: number[], qHigh: number[], actuals: number[]): Promise<void> {\n    if (qLow.length !== qHigh.length || qLow.length !== actuals.length) {\n      throw new Error('All arrays must have same length');\n    }\n\n    if (qLow.length === 0) {\n      throw new Error('At least one calibration sample required');\n    }\n\n    // Compute nonconformity scores for quantile predictions\n    const scores: number[] = [];\n    for (let i = 0; i < qLow.length; i++) {\n      const score = Math.max(qLow[i] - actuals[i], actuals[i] - qHigh[i]);\n      scores.push(score);\n    }\n\n    // Sort for quantile\n    scores.sort((a, b) => a - b);\n    this.calibrationScores = scores;\n    this.nCalibration = scores.length;\n    this.updateQuantile();\n  }\n\n  /**\n   * Make CQR prediction with adjusted quantile bounds\n   *\n   * @param qLow - Lower quantile prediction from model\n   * @param qHigh - Upper quantile prediction from model\n   * @returns PredictionInterval with adjusted bounds\n   */\n  predict(qLow: number, qHigh: number): PredictionInterval {\n    if (this.nCalibration === 0) {\n      throw new Error('Predictor not calibrated');\n    }\n\n    // Adjust quantiles by computed quantile threshold\n    const lower = qLow - this.quantile;\n    const upper = qHigh + this.quantile;\n    const point = (qLow + qHigh) / 2;\n\n    return new PredictionIntervalImpl(point, lower, upper, this.alpha, this.quantile);\n  }\n\n  /**\n   * Update with new observation\n   *\n   * @param qLow - Lower quantile prediction\n   * @param qHigh - Upper quantile prediction\n   * @param actual - Actual observed value\n   */\n  async update(qLow: number, qHigh: number, actual: number): Promise<void> {\n    const score = Math.max(qLow - actual, actual - qHigh);\n    const insertPos = this.binarySearchInsertPosition(score);\n    this.calibrationScores.splice(insertPos, 0, score);\n\n    if (this.calibrationScores.length > this.calibrationSize) {\n      this.calibrationScores.shift();\n    }\n\n    this.nCalibration = this.calibrationScores.length;\n    this.updateQuantile();\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats() {\n    return {\n      nCalibration: this.nCalibration,\n      alpha: this.alpha,\n      alphaLow: this.alphaLow,\n      alphaHigh: this.alphaHigh,\n      quantile: this.quantile,\n      minScore: this.calibrationScores[0] ?? 0,\n      maxScore: this.calibrationScores[this.nCalibration - 1] ?? 0,\n    };\n  }\n\n  /**\n   * Update quantile threshold\n   * @private\n   */\n  private updateQuantile(): void {\n    if (this.nCalibration === 0) {\n      this.quantile = 0;\n      return;\n    }\n\n    const index = Math.ceil((this.nCalibration + 1) * (1 - this.alpha)) - 1;\n    const clampedIndex = Math.max(0, Math.min(index, this.nCalibration - 1));\n    this.quantile = this.calibrationScores[clampedIndex];\n  }\n\n  /**\n   * Binary search insertion position\n   * @private\n   */\n  private binarySearchInsertPosition(score: number): number {\n    let left = 0;\n    let right = this.calibrationScores.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.calibrationScores[mid] < score) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n\n    return left;\n  }\n}\n","/**\n * Factory pattern for automatic implementation selection\n * Detects and uses best available implementation: native > WASM > pure JS\n */\n\nimport { SplitConformalPredictor, AdaptiveConformalPredictor } from './pure/conformal';\nimport type { NonconformityScore } from './pure/scores';\n\nexport type ImplementationType = 'native' | 'wasm' | 'pure';\n\nexport interface PredictorImplementation {\n  type: ImplementationType;\n  predictor: SplitConformalPredictor | AdaptiveConformalPredictor;\n}\n\n/**\n * Factory configuration options\n */\nexport interface FactoryConfig {\n  alpha?: number;\n  scoreFunction?: NonconformityScore;\n  implementation?: 'auto' | 'native' | 'wasm' | 'pure';\n  preferNative?: boolean;\n  fallbackToWasm?: boolean;\n  fallbackToPure?: boolean;\n}\n\nexport interface AdaptiveFactoryConfig extends FactoryConfig {\n  targetCoverage?: number;\n  gamma?: number;\n}\n\n/**\n * Detect available implementations\n * @internal\n */\nasync function detectImplementations(): Promise<Set<ImplementationType>> {\n  const available = new Set<ImplementationType>();\n\n  // Always available\n  available.add('pure');\n\n  // Try to detect WASM (optional)\n  try {\n    // Check if wasm module can be imported\n    if (typeof globalThis !== 'undefined') {\n      // Would load WASM package if available\n      // For now, mark as potentially available but we won't use it\n      // available.add('wasm');\n    }\n  } catch (e) {\n    // WASM not available\n  }\n\n  // Try to detect native addon (optional)\n  try {\n    // Check for native binding through optional dependency\n    // eslint-disable-next-line global-require, @typescript-eslint/no-var-requires\n    const nativeModule = require('@neural-trader/predictor-native');\n    if (nativeModule) {\n      available.add('native');\n    }\n  } catch (e) {\n    // Native binding not available\n  }\n\n  return available;\n}\n\n/**\n * Select best available implementation\n * Priority: native > wasm > pure\n * @internal\n */\nasync function selectImplementation(\n  options: FactoryConfig\n): Promise<ImplementationType> {\n  if (options.implementation && options.implementation !== 'auto') {\n    return options.implementation;\n  }\n\n  const available = await detectImplementations();\n\n  // Explicit preference\n  if (options.preferNative && available.has('native')) {\n    return 'native';\n  }\n\n  if (options.fallbackToWasm && available.has('wasm')) {\n    return 'wasm';\n  }\n\n  // Default priority: native > wasm > pure\n  if (available.has('native')) {\n    return 'native';\n  }\n\n  if (available.has('wasm')) {\n    return 'wasm';\n  }\n\n  return 'pure';\n}\n\n/**\n * Create a SplitConformalPredictor with automatic implementation selection\n *\n * Automatically detects and uses the best available implementation:\n * - Native (NAPI-rs): Fastest, requires compilation\n * - WASM: Good performance, smaller bundle size (requires wasm-pack)\n * - Pure JS: Always available, works everywhere\n *\n * @param config - Configuration options\n * @param scoreFunction - Nonconformity score function\n * @returns Promise resolving to predictor and implementation type\n *\n * @example\n * ```typescript\n * const { predictor, type } = await createPredictor({\n *   alpha: 0.1,\n *   preferNative: true,\n * });\n *\n * console.log(`Using ${type} implementation`);\n * await predictor.calibrate(predictions, actuals);\n * ```\n */\nexport async function createPredictor(\n  config: FactoryConfig = {},\n  scoreFunction?: NonconformityScore\n): Promise<{ predictor: SplitConformalPredictor; type: ImplementationType }> {\n  const implementation = await selectImplementation(config);\n\n  let predictor: SplitConformalPredictor;\n\n  if (implementation === 'native') {\n    try {\n      // Lazy load native implementation\n      const { NativeConformalPredictor } = await lazyLoadNative();\n      predictor = new NativeConformalPredictor(\n        { alpha: config.alpha },\n        scoreFunction\n      );\n      return { predictor, type: 'native' };\n    } catch (e) {\n      console.warn('Failed to load native implementation, falling back to WASM', e);\n    }\n  }\n\n  if (implementation === 'wasm' || implementation === 'native') {\n    try {\n      // Lazy load WASM implementation\n      const { WasmConformalPredictor } = await lazyLoadWasm();\n      predictor = new WasmConformalPredictor(\n        { alpha: config.alpha },\n        scoreFunction\n      );\n      return { predictor, type: 'wasm' };\n    } catch (e) {\n      console.warn('Failed to load WASM implementation, falling back to pure JS', e);\n    }\n  }\n\n  // Always available pure JS fallback\n  predictor = new SplitConformalPredictor(\n    { alpha: config.alpha },\n    scoreFunction\n  );\n  return { predictor, type: 'pure' };\n}\n\n/**\n * Create an AdaptiveConformalPredictor with automatic implementation selection\n *\n * Same as createPredictor but for adaptive variant\n *\n * @param config - Configuration options\n * @param scoreFunction - Nonconformity score function\n * @returns Promise resolving to adaptive predictor and implementation type\n */\nexport async function createAdaptivePredictor(\n  config: AdaptiveFactoryConfig = {},\n  scoreFunction?: NonconformityScore\n): Promise<{ predictor: AdaptiveConformalPredictor; type: ImplementationType }> {\n  const implementation = await selectImplementation(config);\n\n  let predictor: AdaptiveConformalPredictor;\n\n  if (implementation === 'native') {\n    try {\n      // Lazy load native implementation\n      const { NativeAdaptiveConformalPredictor } = await lazyLoadNative();\n      predictor = new NativeAdaptiveConformalPredictor(\n        {\n          targetCoverage: config.targetCoverage,\n          gamma: config.gamma,\n        },\n        scoreFunction\n      );\n      return { predictor, type: 'native' };\n    } catch (e) {\n      console.warn('Failed to load native implementation, falling back to WASM', e);\n    }\n  }\n\n  if (implementation === 'wasm' || implementation === 'native') {\n    try {\n      // Lazy load WASM implementation\n      const { WasmAdaptiveConformalPredictor } = await lazyLoadWasm();\n      predictor = new WasmAdaptiveConformalPredictor(\n        {\n          targetCoverage: config.targetCoverage,\n          gamma: config.gamma,\n        },\n        scoreFunction\n      );\n      return { predictor, type: 'wasm' };\n    } catch (e) {\n      console.warn('Failed to load WASM implementation, falling back to pure JS', e);\n    }\n  }\n\n  // Always available pure JS fallback\n  predictor = new AdaptiveConformalPredictor(\n    {\n      targetCoverage: config.targetCoverage,\n      gamma: config.gamma,\n    },\n    scoreFunction\n  );\n  return { predictor, type: 'pure' };\n}\n\n/**\n * Lazy load native NAPI implementation\n * @internal\n */\nasync function lazyLoadNative(): Promise<any> {\n  // Dynamic import for lazy loading\n  if (typeof globalThis !== 'undefined' && typeof require !== 'undefined') {\n    try {\n      // @ts-expect-error - Optional native dependency may not be installed\n      return await import('@neural-trader/predictor-native');\n    } catch (e) {\n      throw new Error('Native implementation not available');\n    }\n  }\n  throw new Error('Native implementation not available in this environment');\n}\n\n/**\n * Lazy load WASM implementation\n * @internal\n */\nasync function lazyLoadWasm(): Promise<any> {\n  // Dynamic import for lazy loading\n  try {\n    if (typeof globalThis !== 'undefined') {\n      // Would load WASM module here\n      // @ts-expect-error optional WASM dependency\n      const wasmModule = await import('../wasm-pkg/index.js');\n      return wasmModule;\n    }\n    throw new Error('WASM not available in this environment');\n  } catch (e) {\n    throw new Error('WASM implementation not available');\n  }\n}\n\n/**\n * Detect current implementation type\n * Useful for logging and debugging\n *\n * @returns Promise resolving to available implementation types\n *\n * @example\n * ```typescript\n * const available = await detectAvailableImplementations();\n * console.log('Available implementations:', available);\n * ```\n */\nexport async function detectAvailableImplementations(): Promise<ImplementationType[]> {\n  const available = await detectImplementations();\n  return Array.from(available);\n}\n\n/**\n * Get implementation information\n * @internal\n */\nexport function getImplementationInfo(type: ImplementationType): {\n  name: string;\n  description: string;\n  performance: string;\n} {\n  const info: Record<ImplementationType, any> = {\n    native: {\n      name: 'Native (NAPI-rs)',\n      description: 'High-performance Rust implementation via Node.js native addon',\n      performance: '~1x (baseline, fastest)',\n    },\n    wasm: {\n      name: 'WebAssembly (Rust compiled to WASM)',\n      description: 'Good performance with smaller bundle size than native',\n      performance: '~1-2x slower than native',\n    },\n    pure: {\n      name: 'Pure TypeScript',\n      description: 'Pure JavaScript implementation with no external dependencies',\n      performance: '~5-10x slower than native',\n    },\n  };\n\n  return info[type];\n}\n"]}