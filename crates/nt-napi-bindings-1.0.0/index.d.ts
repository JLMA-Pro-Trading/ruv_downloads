/* auto-generated by NAPI-RS */
/* eslint-disable */

/**
 * Neural Trader - High-Performance Trading System
 *
 * TypeScript bindings for Rust-powered algorithmic trading
 */

// =============================================================================
// Core Trading System
// =============================================================================

export interface JsConfig {
  apiKey?: string
  apiSecret?: string
  baseUrl?: string
  paperTrading: boolean
}

export interface VersionInfo {
  rustCore: string
  napiBindings: string
  rustCompiler: string
}

export class NeuralTrader {
  constructor(config: JsConfig)
  start(): Promise<void>
  stop(): Promise<void>
  getPositions(): Promise<JsPosition[]>
  placeOrder(order: JsOrder): Promise<string>
  getBalance(): Promise<string>
  getEquity(): Promise<string>
}

export function getVersionInfo(): VersionInfo
export function initRuntime(numThreads?: number): void

// =============================================================================
// Broker Integration
// =============================================================================

export interface BrokerConfig {
  brokerType: string  // "alpaca" | "ibkr" | "ccxt" | "oanda" | "questrade" | "lime"
  apiKey: string
  apiSecret: string
  baseUrl?: string
  paperTrading: boolean
  exchange?: string  // For CCXT
}

export interface OrderRequest {
  symbol: string
  side: string  // "buy" | "sell"
  orderType: string  // "market" | "limit" | "stop" | "stop_limit"
  quantity: number
  limitPrice?: number
  stopPrice?: number
  timeInForce: string  // "day" | "gtc" | "ioc" | "fok"
}

export interface OrderResponse {
  orderId: string
  brokerOrderId: string
  status: string  // "pending" | "filled" | "partial" | "cancelled" | "rejected"
  filledQuantity: number
  filledPrice?: number
  timestamp: string
}

export interface AccountBalance {
  cash: number
  equity: number
  buyingPower: number
  currency: string
}

export class BrokerClient {
  constructor(config: BrokerConfig)
  connect(): Promise<boolean>
  disconnect(): Promise<void>
  placeOrder(order: OrderRequest): Promise<OrderResponse>
  cancelOrder(orderId: string): Promise<boolean>
  getOrderStatus(orderId: string): Promise<OrderResponse>
  getAccountBalance(): Promise<AccountBalance>
  listOrders(): Promise<OrderResponse[]>
  getPositions(): Promise<JsPosition[]>
}

export function listBrokerTypes(): string[]
export function validateBrokerConfig(config: BrokerConfig): boolean

// =============================================================================
// Neural Networks
// =============================================================================

export interface ModelConfig {
  modelType: string  // "nhits" | "lstm_attention" | "transformer"
  inputSize: number
  horizon: number
  hiddenSize: number
  numLayers: number
  dropout: number
  learningRate: number
}

export interface TrainingConfig {
  epochs: number
  batchSize: number
  validationSplit: number
  earlyStoppingPatience: number
  useGpu: boolean
}

export interface TrainingMetrics {
  epoch: number
  trainLoss: number
  valLoss: number
  trainMae: number
  valMae: number
}

export interface PredictionResult {
  predictions: number[]
  lowerBound: number[]  // 5th percentile
  upperBound: number[]  // 95th percentile
  timestamp: string
}

export class NeuralModel {
  constructor(config: ModelConfig)
  train(data: number[], targets: number[], trainingConfig: TrainingConfig): Promise<TrainingMetrics[]>
  predict(inputData: number[]): Promise<PredictionResult>
  save(path: string): Promise<string>
  load(path: string): Promise<void>
  getInfo(): Promise<any>
}

export class BatchPredictor {
  constructor()
  addModel(model: NeuralModel): Promise<number>
  predictBatch(inputs: number[][]): Promise<PredictionResult[]>
}

export function listModelTypes(): string[]

// =============================================================================
// Risk Management
// =============================================================================

export interface RiskConfig {
  confidenceLevel: number
  lookbackPeriods: number
  method: string  // "parametric" | "historical" | "monte_carlo"
}

export interface VaRResult {
  varAmount: number
  varPercentage: number
  confidenceLevel: number
  method: string
  portfolioValue: number
}

export interface CVaRResult {
  cvarAmount: number
  cvarPercentage: number
  varAmount: number
  confidenceLevel: number
}

export interface DrawdownMetrics {
  maxDrawdown: number
  maxDrawdownDuration: number
  currentDrawdown: number
  recoveryFactor: number
}

export interface KellyResult {
  kellyFraction: number
  halfKelly: number
  quarterKelly: number
  winRate: number
  avgWin: number
  avgLoss: number
}

export interface PositionSize {
  shares: number
  dollarAmount: number
  percentageOfPortfolio: number
  maxLoss: number
  reasoning: string
}

export class RiskManager {
  constructor(config: RiskConfig)
  calculateVar(returns: number[], portfolioValue: number): VaRResult
  calculateCvar(returns: number[], portfolioValue: number): CVaRResult
  calculateKelly(winRate: number, avgWin: number, avgLoss: number): KellyResult
  calculateDrawdown(equityCurve: number[]): DrawdownMetrics
  calculatePositionSize(
    portfolioValue: number,
    pricePerShare: number,
    riskPerTrade: number,
    stopLossDistance: number
  ): PositionSize
  validatePosition(positionSize: number, portfolioValue: number, maxPositionPercentage: number): boolean
}

export function calculateSharpeRatio(returns: number[], riskFreeRate: number, annualizationFactor: number): number
export function calculateSortinoRatio(returns: number[], targetReturn: number, annualizationFactor: number): number
export function calculateMaxLeverage(portfolioValue: number, volatility: number, maxVolatilityTarget: number): number

// =============================================================================
// Backtesting
// =============================================================================

export interface BacktestConfig {
  initialCapital: number
  startDate: string
  endDate: string
  commission: number
  slippage: number
  useMarkToMarket: boolean
}

export interface Trade {
  symbol: string
  entryDate: string
  exitDate: string
  entryPrice: number
  exitPrice: number
  quantity: number
  pnl: number
  pnlPercentage: number
  commissionPaid: number
}

export interface BacktestMetrics {
  totalReturn: number
  annualReturn: number
  sharpeRatio: number
  sortinoRatio: number
  maxDrawdown: number
  winRate: number
  profitFactor: number
  totalTrades: number
  winningTrades: number
  losingTrades: number
  avgWin: number
  avgLoss: number
  largestWin: number
  largestLoss: number
  finalEquity: number
}

export interface BacktestResult {
  metrics: BacktestMetrics
  trades: Trade[]
  equityCurve: number[]
  dates: string[]
}

export class BacktestEngine {
  constructor(config: BacktestConfig)
  run(signals: Signal[], marketData: any): Promise<BacktestResult>
  calculateMetrics(equityCurve: number[]): BacktestMetrics
  exportTradesCsv(trades: Trade[]): string
}

export function compareBacktests(results: BacktestResult[]): any

// =============================================================================
// Market Data
// =============================================================================

export interface Bar {
  symbol: string
  timestamp: string
  open: number
  high: number
  low: number
  close: number
  volume: number
}

export interface Quote {
  symbol: string
  bid: number
  ask: number
  bidSize: number
  askSize: number
  last: number
  lastSize: number
  timestamp: string
}

export interface MarketDataConfig {
  provider: string  // "alpaca" | "polygon" | "yahoo" | "binance"
  apiKey?: string
  apiSecret?: string
  websocketEnabled: boolean
}

export class MarketDataProvider {
  constructor(config: MarketDataConfig)
  connect(): Promise<boolean>
  disconnect(): Promise<void>
  fetchBars(symbol: string, start: string, end: string, timeframe: string): Promise<Bar[]>
  getQuote(symbol: string): Promise<Quote>
  subscribeQuotes(symbols: string[], callback: (quote: Quote) => void): SubscriptionHandle
  getQuotesBatch(symbols: string[]): Promise<Quote[]>
  isConnected(): Promise<boolean>
}

export class SubscriptionHandle {
  unsubscribe(): Promise<void>
}

export function calculateSma(prices: number[], period: number): number[]
export function calculateRsi(prices: number[], period: number): number[]
export function listDataProviders(): string[]

// =============================================================================
// Strategy System
// =============================================================================

export interface Signal {
  id: string
  strategyId: string
  symbol: string
  direction: string  // "long" | "short" | "close"
  confidence: number
  entryPrice?: number
  stopLoss?: number
  takeProfit?: number
  reasoning: string
  timestampNs: number
}

export interface StrategyConfig {
  name: string
  symbols: string[]
  parameters: any
}

export class StrategyRunner {
  constructor()
  addMomentumStrategy(config: StrategyConfig): Promise<string>
  addMeanReversionStrategy(config: StrategyConfig): Promise<string>
  addArbitrageStrategy(config: StrategyConfig): Promise<string>
  generateSignals(): Promise<Signal[]>
  subscribeSignals(callback: (signal: Signal) => void): SubscriptionHandle
  listStrategies(): Promise<string[]>
  removeStrategy(strategyId: string): Promise<boolean>
}

// =============================================================================
// Portfolio Management
// =============================================================================

export interface JsPosition {
  symbol: string
  quantity: string
  avgEntryPrice: string
  currentPrice: string
  unrealizedPnl: string
  side: string
  marketValue: string
}

export interface Position {
  symbol: string
  quantity: number
  avgCost: number
  marketValue: number
  unrealizedPnl: number
  realizedPnl: number
}

export interface PortfolioOptimization {
  allocations: Record<string, number>
  expectedReturn: number
  risk: number
  sharpeRatio: number
}

export interface RiskMetrics {
  var95: number
  cvar95: number
  beta: number
  sharpeRatio: number
  maxDrawdown: number
}

export interface OptimizerConfig {
  riskFreeRate: number
  maxPositionSize?: number
  minPositionSize?: number
}

export class PortfolioOptimizer {
  constructor(config: OptimizerConfig)
  optimize(symbols: string[], returns: number[], covariance: number[]): Promise<PortfolioOptimization>
  calculateRisk(positions: Record<string, number>): RiskMetrics
}

export class PortfolioManager {
  constructor(initialCash: number)
  getPositions(): Promise<Position[]>
  getPosition(symbol: string): Promise<Position | null>
  updatePosition(symbol: string, quantity: number, price: number): Promise<Position>
  getCash(): Promise<number>
  getTotalValue(): Promise<number>
  getTotalPnl(): Promise<number>
}

// =============================================================================
// Orders and Execution
// =============================================================================

export interface JsOrder {
  id: string
  symbol: string
  side: string
  orderType: string
  quantity: string
  limitPrice?: string
  stopPrice?: string
  timeInForce: string
}

export interface JsBar {
  symbol: string
  timestamp: string
  open: string
  high: string
  low: string
  close: string
  volume: string
}

export interface JsSignal {
  id: string
  strategyId: string
  symbol: string
  direction: string
  confidence: number
  entryPrice?: string
  stopLoss?: string
  takeProfit?: string
  quantity?: string
  reasoning: string
  timestamp: string
}

// =============================================================================
// Utility Functions
// =============================================================================

export function fetchMarketData(
  symbol: string,
  start: string,
  end: string,
  timeframe: string
): Promise<JsBar[]>

export function calculateIndicator(
  bars: JsBar[],
  indicator: string,
  params: string
): Promise<number[]>

export function encodeBarsToBuffer(bars: JsBar[]): Buffer
export function decodeBarsFromBuffer(buffer: Buffer): JsBar[]
