#!/usr/bin/env node
import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { WasmConsciousnessSystem } from '../../pkg/nano-consciousness';

export function createConsciousnessCommand() {
  const consciousness = new Command('consciousness');

  consciousness
    .description('Neural consciousness system with temporal processing')
    .option('-v, --verbose', 'Enable verbose output');

  consciousness
    .command('start')
    .description('Start a consciousness system')
    .option('-c, --config <file>', 'Configuration file')
    .option('-p, --phi-threshold <value>', 'Phi threshold for consciousness', '0.5')
    .option('-l, --loop-depth <value>', 'Strange loop depth', '5')
    .option('-w, --window-size <value>', 'Temporal window size', '100')
    .action(async (options) => {
      const spinner = ora('Initializing consciousness system...').start();

      try {
        const system = new WasmConsciousnessSystem();
        system.start();

        spinner.succeed('Consciousness system started');

        console.log(chalk.cyan('\nðŸ“Š System Status:'));
        console.log(chalk.gray('  Phi Threshold:'), options.phiThreshold);
        console.log(chalk.gray('  Loop Depth:'), options.loopDepth);
        console.log(chalk.gray('  Window Size:'), options.windowSize);

        return system;
      } catch (error) {
        spinner.fail('Failed to start consciousness system');
        console.error(chalk.red(error.message));
        process.exit(1);
      }
    });

  consciousness
    .command('process')
    .description('Process input through consciousness system')
    .argument('<input>', 'Input data (comma-separated values or file)')
    .option('-m, --measure-phi', 'Measure integrated information (Î¦)')
    .option('-a, --attention', 'Show attention weights')
    .option('-t, --temporal', 'Enable temporal processing')
    .action(async (input, options) => {
      const spinner = ora('Processing input...').start();

      try {
        const system = new WasmConsciousnessSystem();
        system.start();

        // Parse input
        let inputData: number[];
        if (input.includes(',')) {
          inputData = input.split(',').map((v: string) => parseFloat(v));
        } else {
          // Assume it's a pattern name
          inputData = generatePattern(input, 16);
        }

        // Process
        const consciousness = system.process_input(new Float64Array(inputData));
        spinner.succeed('Input processed');

        console.log(chalk.cyan('\nðŸ§  Results:'));
        console.log(chalk.green(`  Consciousness Level: ${consciousness.toFixed(4)}`));

        if (options.measurePhi) {
          const phi = system.get_phi();
          console.log(chalk.magenta(`  Î¦ (Integrated Information): ${phi.toFixed(4)}`));
        }

        if (options.attention) {
          const attention = system.get_attention_weights();
          console.log(chalk.yellow(`  Attention Weights: [${attention.slice(0, 5).map((a: number) => a.toFixed(2)).join(', ')}...]`));
        }

        if (options.temporal) {
          const binding = system.get_temporal_binding();
          console.log(chalk.blue(`  Temporal Binding: ${binding.toFixed(4)}`));
        }

      } catch (error) {
        spinner.fail('Failed to process input');
        console.error(chalk.red(error.message));
        process.exit(1);
      }
    });

  consciousness
    .command('benchmark')
    .description('Run performance benchmarks')
    .option('-i, --iterations <value>', 'Number of iterations', '1000')
    .option('-c, --compare', 'Compare with classical approach')
    .action(async (options) => {
      const spinner = ora('Running benchmarks...').start();

      try {
        const system = new WasmConsciousnessSystem();
        system.start();

        const iterations = parseInt(options.iterations);
        const results = system.benchmark(iterations);

        spinner.succeed('Benchmarks complete');

        console.log(chalk.cyan('\nâš¡ Performance Results:'));
        console.log(chalk.gray(`  Iterations: ${results.iterations}`));
        console.log(chalk.gray(`  Total Time: ${results.total_time.toFixed(3)}s`));
        console.log(chalk.gray(`  Avg Time: ${(results.avg_time * 1000).toFixed(2)}ms`));
        console.log(chalk.green(`  Throughput: ${(iterations / results.total_time).toFixed(0)} ops/sec`));

        if (options.compare) {
          // Simulate classical O(nÂ²) approach
          const classicalTime = iterations * 0.01; // 10ms per iteration
          const speedup = classicalTime / results.total_time;
          console.log(chalk.yellow(`\n  Speedup vs Classical: ${speedup.toFixed(1)}x faster`));
          console.log(chalk.gray(`  Complexity: O(log n) vs O(nÂ²)`));
        }

      } catch (error) {
        spinner.fail('Benchmark failed');
        console.error(chalk.red(error.message));
        process.exit(1);
      }
    });

  consciousness
    .command('temporal')
    .description('Demonstrate temporal advantage')
    .option('-d, --distance <km>', 'Distance in kilometers', '10900')
    .option('-s, --size <value>', 'Problem size', '1000')
    .action(async (options) => {
      const spinner = ora('Calculating temporal advantage...').start();

      try {
        const distance = parseFloat(options.distance);
        const size = parseInt(options.size);

        // Light travel time
        const lightSpeed = 299792.458; // km/s
        const lightTime = distance / lightSpeed * 1000; // ms

        // Computational time (logarithmic)
        const computeTime = Math.log2(size) * 0.1; // ms

        const advantage = lightTime - computeTime;

        spinner.succeed('Temporal advantage calculated');

        console.log(chalk.cyan('\nâ±ï¸  Temporal Advantage:'));
        console.log(chalk.gray(`  Distance: ${distance} km`));
        console.log(chalk.gray(`  Light Travel Time: ${lightTime.toFixed(2)}ms`));
        console.log(chalk.gray(`  Computation Time: ${computeTime.toFixed(2)}ms`));
        console.log(chalk.green(`  Temporal Advantage: ${advantage.toFixed(2)}ms ahead`));

        if (advantage > 0) {
          console.log(chalk.yellow(`\n  âœ¨ Processing completes ${advantage.toFixed(2)}ms before data arrives!`));
        }

      } catch (error) {
        spinner.fail('Failed to calculate temporal advantage');
        console.error(chalk.red(error.message));
        process.exit(1);
      }
    });

  return consciousness;
}

function generatePattern(name: string, size: number): number[] {
  switch (name.toLowerCase()) {
    case 'sine':
      return Array.from({ length: size }, (_, i) => Math.sin(i * 0.5));
    case 'random':
      return Array.from({ length: size }, () => Math.random());
    case 'spike':
      return Array.from({ length: size }, (_, i) => i % 4 === 0 ? 1.0 : 0.2);
    case 'complex':
      return Array.from({ length: size }, (_, i) =>
        Math.sin(i * 0.1) * Math.cos(i * 0.3) + Math.random() * 0.1
      );
    default:
      return Array.from({ length: size }, () => 0.5);
  }
}

// Export for MCP integration
export const consciousnessTools = {
  processInput: async (input: number[]): Promise<number> => {
    const system = new WasmConsciousnessSystem();
    system.start();
    return system.process_input(new Float64Array(input));
  },

  measurePhi: async (): Promise<number> => {
    const system = new WasmConsciousnessSystem();
    system.start();
    return system.get_phi();
  },

  getAttention: async (): Promise<Float64Array> => {
    const system = new WasmConsciousnessSystem();
    system.start();
    return system.get_attention_weights();
  },

  temporalBinding: async (): Promise<number> => {
    const system = new WasmConsciousnessSystem();
    system.start();
    return system.get_temporal_binding();
  },

  benchmark: async (iterations: number): Promise<any> => {
    const system = new WasmConsciousnessSystem();
    system.start();
    return system.benchmark(iterations);
  }
};