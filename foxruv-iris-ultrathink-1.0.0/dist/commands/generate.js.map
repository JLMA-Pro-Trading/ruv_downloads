{"version":3,"sources":["../../src/cli/commands/generate.ts"],"names":[],"mappings":"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","file":"generate.js","sourcesContent":["import { Command } from 'commander';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { existsSync } from 'fs';\nimport { readFile, writeFile, mkdir } from 'fs/promises';\nimport { resolve, dirname } from 'path';\n\nexport const generateCommand = new Command('generate')\n  .alias('gen')\n  .description('Generate MCP wrapper from OpenAPI spec or MCP server config')\n  .argument('[source]', 'OpenAPI spec file or MCP server URL')\n  .option('-o, --output <path>', 'Output directory', './src/generated')\n  .option('-n, --name <name>', 'Wrapper name')\n  .option('-t, --type <type>', 'Source type: openapi, mcp, or auto', 'auto')\n  .option('--no-types', 'Skip TypeScript type generation')\n  .option('--no-validation', 'Skip input validation')\n  .option('--experimental', 'Enable experimental features')\n  .action(async (source, options) => {\n    const spinner = ora('Generating MCP wrapper...').start();\n\n    try {\n      // Validate source\n      if (!source) {\n        spinner.fail('Source file or URL is required');\n        process.exit(1);\n      }\n\n      spinner.text = 'Reading source specification...';\n\n      let sourceData: any;\n      const sourceType = options.type === 'auto' ? detectSourceType(source) : options.type;\n\n      if (sourceType === 'openapi') {\n        sourceData = await readOpenAPISpec(source);\n        spinner.succeed('OpenAPI specification loaded');\n      } else if (sourceType === 'mcp') {\n        sourceData = await readMCPConfig(source);\n        spinner.succeed('MCP configuration loaded');\n      } else {\n        spinner.fail(`Unknown source type: ${sourceType}`);\n        process.exit(1);\n      }\n\n      // Generate wrapper\n      spinner.start('Generating wrapper code...');\n      const wrapperName = options.name || generateWrapperName(source);\n      const outputPath = resolve(options.output);\n\n      await mkdir(outputPath, { recursive: true });\n\n      // Generate main wrapper\n      const wrapperCode = generateWrapperCode(sourceData, {\n        name: wrapperName,\n        types: options.types,\n        validation: options.validation,\n        experimental: options.experimental\n      });\n\n      const wrapperFile = resolve(outputPath, `${wrapperName}.ts`);\n      await writeFile(wrapperFile, wrapperCode, 'utf-8');\n\n      // Generate types if enabled\n      if (options.types) {\n        spinner.text = 'Generating TypeScript types...';\n        const typesCode = generateTypesCode(sourceData);\n        const typesFile = resolve(outputPath, `${wrapperName}.types.ts`);\n        await writeFile(typesFile, typesCode, 'utf-8');\n      }\n\n      // Generate index file\n      const indexCode = generateIndexCode(wrapperName, options.types);\n      const indexFile = resolve(outputPath, 'index.ts');\n      await writeFile(indexFile, indexCode, 'utf-8');\n\n      spinner.succeed(chalk.green(`Wrapper generated successfully!`));\n      console.log(chalk.cyan(`\\nOutput: ${outputPath}`));\n      console.log(chalk.gray(`  ${wrapperFile}`));\n      if (options.types) {\n        console.log(chalk.gray(`  ${resolve(outputPath, `${wrapperName}.types.ts`)}`));\n      }\n      console.log(chalk.gray(`  ${indexFile}`));\n\n    } catch (error) {\n      spinner.fail(chalk.red('Generation failed'));\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      if (options.parent?.opts().debug) {\n        console.error(error);\n      }\n      process.exit(1);\n    }\n  });\n\nfunction detectSourceType(source: string): 'openapi' | 'mcp' | 'unknown' {\n  if (source.endsWith('.json') || source.endsWith('.yaml') || source.endsWith('.yml')) {\n    return 'openapi';\n  }\n  if (source.startsWith('http://') || source.startsWith('https://') || source.startsWith('stdio://')) {\n    return 'mcp';\n  }\n  return 'unknown';\n}\n\nasync function readOpenAPISpec(source: string): Promise<any> {\n  if (existsSync(source)) {\n    const content = await readFile(source, 'utf-8');\n    return JSON.parse(content);\n  }\n  throw new Error(`OpenAPI spec file not found: ${source}`);\n}\n\nasync function readMCPConfig(source: string): Promise<any> {\n  // TODO: Implement MCP server introspection\n  throw new Error('MCP config reading not yet implemented');\n}\n\nfunction generateWrapperName(source: string): string {\n  const basename = source.split('/').pop()?.split('.')[0] || 'wrapper';\n  return basename.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();\n}\n\nfunction generateWrapperCode(sourceData: any, options: {\n  name: string;\n  types: boolean;\n  validation: boolean;\n  experimental: boolean;\n}): string {\n  return `// Generated by ultrathink\n// Source: ${options.name}\n// Generated at: ${new Date().toISOString()}\n\n${options.types ? `import type * as Types from './${options.name}.types.js';` : ''}\n\nexport class ${toPascalCase(options.name)}Wrapper {\n  constructor(private config: any) {}\n\n  // TODO: Implement wrapper methods\n  async initialize(): Promise<void> {\n    console.log('Initializing ${options.name} wrapper...');\n  }\n\n  async callTool(name: string, args: any): Promise<any> {\n    // TODO: Implement tool calling\n    throw new Error('Not implemented');\n  }\n}\n\nexport default ${toPascalCase(options.name)}Wrapper;\n`;\n}\n\nfunction generateTypesCode(sourceData: any): string {\n  return `// Generated TypeScript types\n// Generated at: ${new Date().toISOString()}\n\nexport interface Config {\n  // TODO: Generate config types\n}\n\nexport interface ToolResult {\n  success: boolean;\n  data?: any;\n  error?: string;\n}\n`;\n}\n\nfunction generateIndexCode(wrapperName: string, includeTypes: boolean): string {\n  return `export { default as ${toPascalCase(wrapperName)}Wrapper } from './${wrapperName}.js';\n${includeTypes ? `export type * from './${wrapperName}.types.js';` : ''}\n`;\n}\n\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_]/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n    .join('');\n}\n"]}