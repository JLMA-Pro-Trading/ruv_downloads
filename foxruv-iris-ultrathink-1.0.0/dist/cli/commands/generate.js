import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { existsSync } from 'fs';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { resolve } from 'path';
export const generateCommand = new Command('generate')
    .alias('gen')
    .description('Generate MCP wrapper from OpenAPI spec or MCP server config')
    .argument('[source]', 'OpenAPI spec file or MCP server URL')
    .option('-o, --output <path>', 'Output directory', './src/generated')
    .option('-n, --name <name>', 'Wrapper name')
    .option('-t, --type <type>', 'Source type: openapi, mcp, or auto', 'auto')
    .option('--no-types', 'Skip TypeScript type generation')
    .option('--no-validation', 'Skip input validation')
    .option('--experimental', 'Enable experimental features')
    .action(async (source, options) => {
    const spinner = ora('Generating MCP wrapper...').start();
    try {
        // Validate source
        if (!source) {
            spinner.fail('Source file or URL is required');
            process.exit(1);
        }
        spinner.text = 'Reading source specification...';
        let sourceData;
        const sourceType = options.type === 'auto' ? detectSourceType(source) : options.type;
        if (sourceType === 'openapi') {
            sourceData = await readOpenAPISpec(source);
            spinner.succeed('OpenAPI specification loaded');
        }
        else if (sourceType === 'mcp') {
            sourceData = await readMCPConfig(source);
            spinner.succeed('MCP configuration loaded');
        }
        else {
            spinner.fail(`Unknown source type: ${sourceType}`);
            process.exit(1);
        }
        // Generate wrapper
        spinner.start('Generating wrapper code...');
        const wrapperName = options.name || generateWrapperName(source);
        const outputPath = resolve(options.output);
        await mkdir(outputPath, { recursive: true });
        // Generate main wrapper
        const wrapperCode = generateWrapperCode(sourceData, {
            name: wrapperName,
            types: options.types,
            validation: options.validation,
            experimental: options.experimental
        });
        const wrapperFile = resolve(outputPath, `${wrapperName}.ts`);
        await writeFile(wrapperFile, wrapperCode, 'utf-8');
        // Generate types if enabled
        if (options.types) {
            spinner.text = 'Generating TypeScript types...';
            const typesCode = generateTypesCode(sourceData);
            const typesFile = resolve(outputPath, `${wrapperName}.types.ts`);
            await writeFile(typesFile, typesCode, 'utf-8');
        }
        // Generate index file
        const indexCode = generateIndexCode(wrapperName, options.types);
        const indexFile = resolve(outputPath, 'index.ts');
        await writeFile(indexFile, indexCode, 'utf-8');
        spinner.succeed(chalk.green(`Wrapper generated successfully!`));
        console.log(chalk.cyan(`\nOutput: ${outputPath}`));
        console.log(chalk.gray(`  ${wrapperFile}`));
        if (options.types) {
            console.log(chalk.gray(`  ${resolve(outputPath, `${wrapperName}.types.ts`)}`));
        }
        console.log(chalk.gray(`  ${indexFile}`));
    }
    catch (error) {
        spinner.fail(chalk.red('Generation failed'));
        console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);
        if (options.parent?.opts().debug) {
            console.error(error);
        }
        process.exit(1);
    }
});
function detectSourceType(source) {
    if (source.endsWith('.json') || source.endsWith('.yaml') || source.endsWith('.yml')) {
        return 'openapi';
    }
    if (source.startsWith('http://') || source.startsWith('https://') || source.startsWith('stdio://')) {
        return 'mcp';
    }
    return 'unknown';
}
async function readOpenAPISpec(source) {
    if (existsSync(source)) {
        const content = await readFile(source, 'utf-8');
        return JSON.parse(content);
    }
    throw new Error(`OpenAPI spec file not found: ${source}`);
}
async function readMCPConfig(source) {
    // TODO: Implement MCP server introspection
    throw new Error('MCP config reading not yet implemented');
}
function generateWrapperName(source) {
    const basename = source.split('/').pop()?.split('.')[0] || 'wrapper';
    return basename.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
}
function generateWrapperCode(sourceData, options) {
    return `// Generated by ultrathink
// Source: ${options.name}
// Generated at: ${new Date().toISOString()}

${options.types ? `import type * as Types from './${options.name}.types.js';` : ''}

export class ${toPascalCase(options.name)}Wrapper {
  constructor(private config: any) {}

  // TODO: Implement wrapper methods
  async initialize(): Promise<void> {
    console.log('Initializing ${options.name} wrapper...');
  }

  async callTool(name: string, args: any): Promise<any> {
    // TODO: Implement tool calling
    throw new Error('Not implemented');
  }
}

export default ${toPascalCase(options.name)}Wrapper;
`;
}
function generateTypesCode(sourceData) {
    return `// Generated TypeScript types
// Generated at: ${new Date().toISOString()}

export interface Config {
  // TODO: Generate config types
}

export interface ToolResult {
  success: boolean;
  data?: any;
  error?: string;
}
`;
}
function generateIndexCode(wrapperName, includeTypes) {
    return `export { default as ${toPascalCase(wrapperName)}Wrapper } from './${wrapperName}.js';
${includeTypes ? `export type * from './${wrapperName}.types.js';` : ''}
`;
}
function toPascalCase(str) {
    return str
        .split(/[-_]/)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join('');
}
//# sourceMappingURL=generate.js.map